---
title: "Wine"
author: "Solomon Sapio, Joseph Tseytlin, Nick Bottiglieri"
date: "5/11/2019"
output: html_document
---

Before beginning any data analysis, it is imperative for you to load all of the packages you plan to use. The tidyverse package includes many other r packages that are commonly used such a ggplot and dplyr. 

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
options(warn = -1)
library(tidyverse)
library(leaflet)
```

The first step in the data curation process is to actually get the data. Kaggle is a great resource for datasets and is where we procured this dataset. It is also possible to scrape datasets from the web, and this dataset was originally made from scrapped data of wine reviews from https://www.winemag.com/. Once you find a dataset you like, download the CSV and put it in your project folder. Once you have done this you can load it using the read.csv command used below.  

```{r}
winedata = read.csv("winemag-data-130k-v2.csv")
```

Lets explore our data set. To display the entire data set, simply type the name of your data set, which in our case is winedata. We will be using syntactical sugar available from the dplyr package. This allows us to use piping by doing "%>%" and includes many of the operations we will be using later such as select and filter. For more information on the dplyr package and its features you can refer to the documentation at https://www.rdocumentation.org/packages/dplyr/versions/0.7.8 The code below prints the first few elements of our dataset

```{r}
 winedata %>%
  head()
```

<<<<<<< HEAD

Lets take a look at the distribution of wine ratings (rated from 80 to 100).
=======
We notice that our dataset has some unwanted information, which we remove with select.

```{r}
winedata = winedata %>% 
  select(-taster_twitter_handle) %>%
  select(-description)
```

Lets take a look at the distribution of ratings. 
>>>>>>> 0724daac1d7e84bee3db9efd427fb9a0f41de934
```{r}
winedata %>%
  group_by(points) %>%
  summarize(n = n()) %>%
  ggplot(mapping=aes(x=points, y=n)) +
    geom_bar(stat="identity")
```


What if we want to display only wine reviews from a certain country or a certain province? We can filter our dataset based on attribute values. We can then select certain attributes using the select keyword. Below is an example of filtering our dataset by country (only selecting reviews where the country of origin is Spain) and by points (where the number of points are >90). We then use the select keyword to select only certain attributes to display. Since we filtered based on country and points we will select those attributes as well as identifying attributes to display.  

```{r}
winedata %>% 
  filter(country == "Spain") %>%
  filter(points > 90) %>%
  select(country, points, variety, winery) %>%
  head()
```

Let's start summarizing our dataset in order to get more useful information we can use for data analysis. You have probably noticed that our dataset is a set of wine reviews for various wines. We are going to need to extract the year from the "title" column in the data set in order to use it with our summarization and plotting. First, we use str_extract to extract the year using regular expressions from the title. https://www.rdocumentation.org/packages/stringr/versions/1.4.0/topics/str_extract is a link to the documentation on the extract method. In the same line we create a new column, year, to store the extracted string. Next, we need to convert the year, which is still a string, to an integer, so we use type_convert. https://www.rdocumentation.org/packages/utils/versions/3.6.0/topics/type.convert is a link to read more on type convert. Next, we filter out all of the NA values and then finally summarize the price and points columns in order to make an average of them - we will be using this average later in our graphs.  

```{r}
winedata

winedata <- winedata %>%
  mutate(year = str_extract(title, "(\\d){4}"))

winedata <- winedata %>%
  type_convert(col_types = cols(year = col_integer())) %>%
  filter(year > 0, year < 2020, price > 0)

winedata <- winedata %>%
  group_by(variety, year, winery, province, region_1, country) %>%
  summarize(avg_price = mean(price), avg_rating = mean(points))

winedata
```

Now, we are going to plot some data to learn some things about our dataset. First, we need to include the ggplot2 library to use some of the ggplot methods. Then, we are going to create a new column for the ratio between the average rating and the average price for each wine. This ratio will be higher if the wine is rated high and is cheap and it will be lower if the wine is rated low and expensive. Overall, the more efficient wine will be rated higher. Next, we start the wine plot by grouping by country, summarizing the average rating to price ratio for each country, and summarizing the total number of wines for each country. We find the total number of wines in order to remove any countries that have less than 50 wine reviews. This is because some countries, like Ukraine, only have a small number of reviews and become an outliar in the graph. Lastly, we need to plot the data as a bar graph using ggplot. By looking at the graph, we can see that Romania has the best rating to price ratio and Canada has the lowest ratio.   
  
```{r}
library(ggplot2)

winedata <- winedata %>%
  mutate(ratingpriceratio = avg_rating/avg_price)

wineplot <- winedata %>%
  group_by(country) %>%
  summarize(avg_ratingpriceratio = mean(ratingpriceratio), wine_count = n()) %>%
  filter(wine_count > 50) %>%
  ggplot(mapping = aes(x = country, y = avg_ratingpriceratio)) +
  geom_bar(stat = "identity", fill = "steelblue") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
   labs(title="Average Rating to Price Ratio by Country",
         x = "Country",
         y = "Average Rating to Price Ratio")

wineplot
```


After determining who has the best wine for the best price, we can pose the question if the price affects the quality of the wine? I assume expensive wine would rank higher than innexpensive wine, but we can plot some linear regression lines ourselves to see the difference. First, we only use countries with a significant amount of data collected for them - in this case, Chile, France, Italy, Spain, and the US have an abundance of wine data that will lead to an indisputable conclusion. Next, after filtering, we can plot the average rating over the average price of each wine. Then, we distinguish the data points by country, using the color parameter in the ggplot function. Lastly, we can add geom_smooth(method = lm) to create a line of best fit for our data for each country. By looking at the graph, we can see that there is clearly a linear dependence between price and rating. French wine increases almost 3 points for a 10 dollar increase in price. On the other hand, US wine increases at a slower rate at about 1 point for every 10 dollar increase. Italian wine has a very similar slope to US wine too.  

```{r}
wineplot <- winedata %>%
  group_by(country, avg_price, avg_rating) %>%
  summarize(wine_count = n()) %>%
  filter(wine_count > 50) %>%
  ggplot(mapping = aes(x = avg_price, y = avg_rating, color = country)) +
  geom_smooth(method = lm) +
  labs(title="Average rating over average price, by country",
         x = "Average Price",
         y = "Average Rating")

wineplot
```

Now we are going to investigate the linear regression properties of avg_rating versus average_price
```{r}
auto_fit <- lm(avg_rating~avg_price, data=winedata)
auto_fit
```

As we have demonstrated with the above graphs, a picture is worth a thousand words. So lets see how valuable a map will be! Specifically, let's make an interactive map displaying the origins of the wines in our dataset. To accomplish this task, we use the leaflet library ("https://rstudio.github.io/leaflet/shapes.html"), which allows for excellent interactive plotting in R. Depicting the countries is a little trickier however, we will need to import another third-party dataset that describes country borders. This information is available at "http://thematicmapping.org/downloads/TM_WORLD_BORDERS_SIMPL-0.3.zip" and we load it into a special object called a "Spatial Polygons Data Frame."

```{r, warning=FALSE}
# Download .shp file on the web:
download.file("http://thematicmapping.org/downloads/TM_WORLD_BORDERS_SIMPL-0.3.zip" , destfile="world_shape_file.zip")
unzip("world_shape_file.zip", overwrite = FALSE)
 
# Read the file with the rgdal library in R
library(rgdal)
world_spdf=readOGR( dsn= getwd() , layer="TM_WORLD_BORDERS_SIMPL-0.3")
```

Now have our dataset that describes wines, and another dataset that describes countries and their locations on the map. So we need to join these two together using the almighty join command! It is important to note that we join on the attribute "country", which is shared among both datasets, in order to combine them together.

```{r}

#Count the number of wines from each country
wine_country = winedata %>%
  dplyr::group_by(country) %>%
  dplyr::summarize(wine_count=n())

#prepare the wine data for joining
wine_country$country = as.character(wine_country$country)
wine_country$country[wine_country$country == "US"] ="United States"

#prepare the world data for joining
world_spdf@data = dplyr::rename(world_spdf@data,country=NAME)
world_spdf@data$country = as.character(world_spdf@data$country)

#Join!
winemap = right_join(wine_country, world_spdf@data, by="country")
world_spdf@data = winemap
```

Now that we have the combined wine and world data set, we are ready to create our map. Our map will have certain characteristics: A color palette depicted the number of wines from that area, labels identifying each country on the map and displaying the number of wines from there, and a legend that clearly explains this information. 

```{r}
pal <- colorNumeric(
  palette = "YlOrRd",
  domain = world_spdf@data$wine_count,
  na.color = "transparent"
  )

country_label=paste(world_spdf@data$country,"<br/>", "Number of wines: ", world_spdf@data$wine_count) %>%
lapply(htmltools::HTML)

# Final Map
leaflet(world_spdf) %>% 
  #Tiles are how the map is displayed. We also want to limit the zoom.
  addTiles(options = tileOptions(minZoom = 2))  %>% 
  #Initialize the view
  setView(lat=10, 
          lng=0,
          zoom=2) %>%
  #Display the countries and make them interactive on highlight
  addPolygons(
    fillColor = ~pal(wine_count),
    stroke = FALSE,
    fillOpacity = 0.9, 
    color="white", 
    weight = 0.3,
    highlight = highlightOptions(weight = 5, 
                                 color = "white",
                                 fillOpacity = 0.3,
                                 bringToFront = TRUE),
    label = country_label,
    labelOptions = labelOptions(style = list("font-weight" = "normal", padding = "3px 8px"), 
                                textsize = "13px",  
                                direction = "auto")
  ) %>%
  addLegend( pal=pal, values=~wine_count, opacity=0.9, title = "Wine count", position = "bottomleft" )
```
Fantastic! This map clearly and visually shows where the wines in our dataset originated from. The country with the greatest number of wines in this dataset appears to be the US, with 42472 wines! This makes sense, considering that our dataset comes from a US company. France and Itally are also huge producers of wine, as are Chile and Argentina. Other countries, such as India and China,  are very minimally represented in our dataset.
